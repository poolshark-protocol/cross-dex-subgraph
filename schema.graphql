type Exchange @entity {
  # factory address
  id: ID!

  # pair info
  pairCount: Int!

  pairs: [Pair]!
}

type Observation @entity {
  #tknA_address < tknB_address
  id: ID!
  blockNumber: BigInt!
  timestamp: BigInt!
  transactions: [Transactions!]!
  # tknA/tknB price
  volumeWeightedAvgPrice: BigInt!
}

type Token @entity {
  # token address
  id: ID!

  # mirrored from the smart contract
  symbol: String!
  name: String!
  decimals: BigInt!

  pairs: [Pair!]!
  exchanges: [Exchanges!]!

  # token specific volume
  tradeVolume: BigDecimal!

  # transactions across all pairs
  txCount: BigInt!

  # liquidity across all pairs
  totalLiquidity: BigDecimal!
  
}

type Pair @entity {
  # pool_address for AMMs
  # contract_address + tknA_address < tknB_address for PoolSharks Orderbook
  id: ID!

  # mirrored from the smart contract
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!

  # Price in terms of the asset pair
  token0Price: BigDecimal!
  token1Price: BigDecimal!

  # lifetime volume stats
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  txCount: BigInt!

  # list of all swap for the pair
  swaps: [Swap!]! @derivedFrom(field: "pair")
}

type Transaction @entity {
  id: ID! # txn hash
  blockNumber: BigInt!
  timestamp: BigInt!
  # This is not the reverse of Mint.transaction; it is only used to
  # track incomplete mints (similar for burns and swaps)
  swaps: [Swap]!
}

type Swap @entity {
  # transaction hash + "-" + index in Transaction swaps array
  id: ID!
  exchange: Exchange!
  transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!

  # populated from the Swap event
  sender: Bytes!
  from: Bytes! # the EOA that initiated the txn
  amount0In: BigDecimal!
  amount1In: BigDecimal!
  amount0Out: BigDecimal!
  amount1Out: BigDecimal!
  # note for orderbook: do not emit until fulfilled
  # emit 2 events on fulfill
  # sender/from/to is fulfiller
  # 2nd event (for provider) - sender/from/to is empty
  # 1 of them will have empty fields
  to: Bytes!
  logIndex: BigInt

}

type ExchangePair @entity {
  # pool_address for AMMs
  # contract_address + tknA_address < tknB_address for PoolSharks Orderbook
  id: ID!

  # mirrored from the smart contract
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!

  # derived liquidity
  reserveETH: BigDecimal!
  reserveUSD: BigDecimal!
  # used for separating per pair reserves and global
  trackedReserveETH: BigDecimal!

  # Price in terms of the asset pair
  token0Price: BigDecimal!
  token1Price: BigDecimal!

  # lifetime volume stats
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
  untrackedVolumeUSD: BigDecimal!
  txCount: BigInt!

  # creation stats
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!

  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
  # derived fields
  pairHourData: [PairHourData!]! @derivedFrom(field: "pair")
  liquidityPositions: [LiquidityPosition!]! @derivedFrom(field: "pair")
  liquidityPositionSnapshots: [LiquidityPositionSnapshot!]! @derivedFrom(field: "pair")

  # list of all swap for the pair
  swaps: [Swap!]! @derivedFrom(field: "pair")
}

type Transaction @entity {
  id: ID! # txn hash
  blockNumber: BigInt!
  timestamp: BigInt!
  # This is not the reverse of Mint.transaction; it is only used to
  # track incomplete mints (similar for burns and swaps)
  swaps: [Swap]!
}

type Swap @entity {
  # transaction hash + "-" + index in Transaction swaps array
  id: ID!
  exchange: Exchange!
  transaction: Transaction!
  timestamp: BigInt! # need this to pull recent txns for specific token or pair
  pair: Pair!

  # populated from the Swap event
  sender: Bytes!
  from: Bytes! # the EOA that initiated the txn
  amount0In: BigDecimal!
  amount1In: BigDecimal!
  amount0Out: BigDecimal!
  amount1Out: BigDecimal!
  # note for orderbook: do not emit until fulfilled
  # emit 2 events on fulfill
  # sender/from/to is fulfiller
  # 2nd event (for provider) - sender/from/to is empty
  # 1 of them will have empty fields
  to: Bytes!
  logIndex: BigInt

  # derived info
  amountUSD: BigDecimal!
}
